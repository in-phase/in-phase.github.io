[{"id":0,"href":"/docs/regions_and_chunks/crystal_slicing_mechanisms/","title":"Crystal's Slicing Mechanisms","section":"Regions \u0026 Chunks","content":" Crystal\u0026rsquo;s Slicing Mechanisms # In an Array (or any Indexable), each element is represented by a numeric index. There are a couple different ways to do this\nwe can refer to the elements via positive, increasing indexes as such: arr = [\u0026#39;P\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;e\u0026#39;] # 0 1 2 3 4 arr[0] # =\u0026gt; \u0026#39;P\u0026#39; arr[4] # =\u0026gt; \u0026#39;e\u0026#39; Or, we can start at the other end of the array using negative indexes:\narr = [\u0026#39;P\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;e\u0026#39;] # -5 -4 -3 -2 -1 arr[-1] # =\u0026gt; \u0026#39;e\u0026#39; arr[-5] # =\u0026gt; \u0026#39;P\u0026#39; But the real complication arises when we want to select multiple elements from one array. In Crystal, this is done with a Range, often created with a range literal. A Range describes an ordered collection of indexes by a starting and ending index. Let\u0026rsquo;s construct a Range and see what indexes it refers to:\n# Create a range that starts at 0, and ends at 3 (including 3) range = Range.new(begin: 0, end: 3, exclusive: false) range.to_a # =\u0026gt; [0, 1, 2, 3] So, the range we created starts at 0, increments by 1 until it gives us 3, and then ends. Note that we specified exclusive: false, in that example. It\u0026rsquo;s often useful to exclude the last value (in the example here, 3). Here\u0026rsquo;s an example:\n# Create a range that starts at 0, and ends at 3 (excluding 3) range = Range.new(begin: 0, end: 3, exclusive: true) range.to_a # =\u0026gt; [0, 1, 2] Of course, the syntax shown above is very painful to type out. Instead, we use range literal syntax to shorten the expressions:\n# Inclusive ranges are start..end (two periods are used) inclusive_range = 0..3 inclusive_range.to_a # =\u0026gt; [0, 1, 2, 3] # Exclusive ranges use three periods: 0...3 exclusive_range = 0...3 exclusive_range.to_a #=\u0026gt; [0, 1, 2] Now that we\u0026rsquo;ve seen how a range can refer to multiple indexes, it\u0026rsquo;s easy to use them to sample elements from an array:\n# Let\u0026#39;s extract [\u0026#39;h\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;s\u0026#39;] from this array: arr = [\u0026#39;P\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;e\u0026#39;] # 0 1 2 3 4 # The indexes shown above tell us that we want elements # 1, 2, and 3. So, we\u0026#39;ll construct an appropriate range: selection_range = 1..3 selection_range.to_a # =\u0026gt; [1, 2, 3] # and use it on the array: arr[selection_range] # =\u0026gt; [\u0026#39;h\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;s\u0026#39;] This also works with negative indexes, but the end of the range has to be positively larger than the starting index:\narr = [\u0026#39;P\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;e\u0026#39;] # -5 -4 -3 -2 -1 # Let\u0026#39;s extract the last two letters: selection_range = -2..-1 selection_range.to_a # =\u0026gt; [-2, -1] arr[selection_range] # =\u0026gt; [\u0026#39;s\u0026#39;, \u0026#39;e\u0026#39;] The final thing to note is that ranges can also have undetermined beginnings and ends. For example:\nrange_1 = ..5 # Every integer from -infinity to 5 is, technically, part of this range_2 = 10... # 10, 11, 12 (note that the ... and .. would be identical) range_3 = ...3 # Every integer up to but excluding 3 range_4 = .. # All integers You can\u0026rsquo;t call #to_a on any of those ranges, as an infinite array is not possible, but they take on a special meaning when used for indexing. The end (or ends) that you leave floating will clamp to the start or end of an array like this:\narr = [\u0026#39;P\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;e\u0026#39;] arr[..3] # =\u0026gt; [\u0026#39;P\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;s\u0026#39;] arr[..3] == arr[0..3] # =\u0026gt; true arr[...3] # =\u0026gt; [\u0026#39;P\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;a\u0026#39;]] arr[...3] == arr[0...3] # =\u0026gt; true arr[-3..] # =\u0026gt; [\u0026#39;a\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;e\u0026#39;] arr[-3..] == arr[-3..-1] # =\u0026gt; true arr[..] # =\u0026gt; [\u0026#39;P\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;e\u0026#39;] arr[...] # =\u0026gt; [\u0026#39;P\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;e\u0026#39;] arr[..] == arr[...] # =\u0026gt; true arr[..] == arr[0..-1] # =\u0026gt; true As you can see, the array is truncating the range to fit within its bounds. It will insert a 0 as the range beginning if one isn\u0026rsquo;t given, and a -1 as the range end. Note that, on the rightmost bound, exclusivity will be ignored if you don\u0026rsquo;t provide a fixed end value, because the final index of any array will certainly be less than infinity, and the exclusivity applied to infinity in particular, not just the end of the range.\nNote that, if a range has no upper bound, the number of dots in the ellipsis does not change the function - arr[1..] and arr[1...] always return the same thing.\n"},{"id":1,"href":"/docs/regions_and_chunks/","title":"Regions \u0026 Chunks","section":"Docs","content":" Regions \u0026amp; Chunks # Introduction # At its core, Phase is all about providing an easy to use container for storing large amounts of data. One of the most important parts of that task is providing an easy way for the user to extract a peice of data from the collection - for example, selecting only the first three elements from a vector, or isolating the green channel of an RGB image.\nAlthough it seems very simple, this topic can get quite confusing. Because Phase aims to make scientific computing easier to work with, we\u0026rsquo;re devoting a whole section to this one operation of taking an NArray (or, more specifically, a MultiIndexable) apart.\nTo begin with, we\u0026rsquo;ll review the Array from Crystal\u0026rsquo;s standard library. If you\u0026rsquo;re comfortable with slicing Arrays in Crystal already, skip to MultiIndexable Slicing.\n"},{"id":2,"href":"/docs/tutorials/making-a-multiindexable/","title":"multiindexable_tutorial","section":"Test document","content":" Tutorial: Make Your Own MultiIndexable # Basics # ph-core offers a standard data type, Phase::NArray that will suffice for most of your multidimensional data storage and manipulation needs. However, storing information linearly in memory isn\u0026rsquo;t always the most effective appraoch, and sometimes isn\u0026rsquo;t possible. Phase::MultiIndexable is an interface defining a common set of rules we expect any multidimensional array to obey; and by implementing this interface, you can treat your own type almost like an NArray.\nLet\u0026rsquo;s say we want to be able to access any 5-digit number, using each place value as a coordinate. Since we want our array to return Int32s, that will be the type argument.\nrequire \u0026#34;ph-core\u0026#34; class NumberAccessor \u0026lt; Phase::MultiIndexable(Int32) end This alone won\u0026rsquo;t compile, because the MultiIndexable interface has two abstract methods it expects you to define. So let\u0026rsquo;s do that.\nrequire \u0026#34;ph-core\u0026#34; class NumberAccessor \u0026lt; Phase::MultiIndexable(Int32) def shape [10] * 5 # our NumberAccessor is 5-dimensional, with 10 possible values on each axis end # coord is an Indexable(Int), so we can iterate over it to get each singular *ordinate*. # In this example we are treating ordinates as digits of our final number, with # place values corresponding to their position (index) in the coordinate. def unsafe_fetch_element(coord) : T value = 0 place_value = 1 coord.each do |digit| value += digit * place_value place_value *= 10 end end end That is technically all we need, and we can now start using our NumberAccessor.\n# examples Return Types # Summary: there are several methods that return NArrays by default, but may be overriden to return your own type:\n#unsafe_fetch_chunk(region : IndexRegion) #map(\u0026amp;block) #map_with(*args, \u0026amp;block) .from(other : MultiIndexable) Performance # Summary: there are several methods designed to work for any MultiIndexable, at the possible cost of performance. Some we suggest overriding include:\nIterator methods: #fast, #each Transform methods: #reshape, #permute, #reverse #unsafe_fetch_chunk #size Phase::NArray may offer some inspiration on how these methods work and how they might be optimized.\n"},{"id":3,"href":"/docs/tutorials/","title":"Test document","section":"Docs","content":" Tutorials # tuts!\n"},{"id":4,"href":"/docs/regions_and_chunks/multiindexable_slicing/","title":"MultiIndexable Slicing","section":"Regions \u0026 Chunks","content":" MultiIndexable Slicing # In Phase, slicing multidimensional arrays (MultiIndexabless) is designed to be very similar to slicing ordinary arrays. In fact, for single-dimensional MultiIndexables, slicing is almost identical:\nrequire \u0026#34;phase\u0026#34; include Phase # Vanilla crystal slicing: arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;] arr[1..] # =\u0026gt; [\u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;] # 1D MultiIndexable slicing: narr = NArray[\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;] narr[1..] # =\u0026gt; NArray[\u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;] Basic Example # When we add another dimension, we must specify two sets of indexes. In one dimension, slicing is like cutting a line of elements out of a longer line. In 2D, slicing is like cutting a small square of elements out of a larger sheet, and so on for n-dimensional volumes. For example:\nrequire \u0026#34;phase\u0026#34; include Phase # Create a 2D matrix of elements narr = NArray[[:a, :b, :c, :d], [ 1, 2, 3, 4], [:e, :f, :g, :h]] # Take row 0 and 1, columns 1 and 2: narr[0..1, 1..2] # =\u0026gt; NArray[[:b, :c], # [ 2, 3]] Regions \u0026amp; Chunks # In the familiar array paradigm, an index is a number that points at an element of the array. In high level languages like Crystal, we\u0026rsquo;ve seen that this can be extended further - a range of indices can point at a list of elements, like arr[1..] as seen earlier.\nAlthough it is possible to describe everything that Phase does using this one-dimensional language, it gets tedious pretty quickly. In Phase, we refer to a collection of indices as a coordinate and a collection of coordinates as a region.\nFinally, in the same way that an index points to an element - a region points to a chunk of elements from the MultiIndexable.\nTo connect this to the previous example:\nrequire \u0026#34;phase\u0026#34; include Phase # This NArray is made of *elements* located at *coordinates* narr = NArray[[:a, :b, :c, :d], [ 1, 2, 3, 4], [:e, :f, :g, :h]] # For example, the :b is located at coordinate [0, 1]: narr.get(0, 1) # =\u0026gt; :b # To take row 0, 1, and columns 1, 2, we want to select the coordinates # [0, 1], [0, 2], [1, 1], and [1, 2]. We denote this using the ranges # as a shorthand - the collection of coordinates described here describes # a *region* region = [0..1, 1..2] # Now, we can use this *region* to get a *chunk*: narr[region] # =\u0026gt; NArray[[:b, :c], # [ 2, 3]] Implicit Syntax # It can get tedious to type out .. over and over. Phase will automatically fill out a region with .. until the correct number of dimensions is reached for a slicing operation:\nrequire \u0026#34;phase\u0026#34; include Phase narr = NArray[[:a, :b, :c, :d], [ 1, 2, 3, 4], [:e, :f, :g, :h]] # Select rows 1 and 2 with all columns: narr[0..1, ..] # =\u0026gt; NArray[[:a, :b, :c, :d], [1, 2, 3, 4]] # Identically, use the implicit syntax: narr[0..1] # =\u0026gt; NArray[[:a, :b, :c, :d], [1, 2, 3, 4]] # Phase will add `..` to the right side: [0..1] =\u0026gt; [0..1, ..] # This also works for any number of dimensions. In a 5D array, # narr[0..3, 2] == narr[0..3, 2, .., .., ..] Dimension Dropping # It is often the case that you\u0026rsquo;ll want to select a simple chunk from a higher-dimensional data structure - for example, a single row from a matrix, or a single color channel from an image. This is distinct from dimension-preserving cases, because you will specify an integer, not a range, in one or more of the ordinates:\nrequire \u0026#34;phase\u0026#34; include Phase narr = NArray[[1, 2], [3, 4]] # Here, the 0 is an integer, not a range. Phase will strip a dimension # off of the result, as shown - we get a 1D NArray from the 2D matrix `narr`. first_row = narr[0, ..] # =\u0026gt; NArray[1, 2] # By counterexample, we can select the first row *as a matrix* by using a # single-index range: first_row_as_matrix = narr[0..0, ..] # =\u0026gt; NArray[[1, 2]] This also explains the use of MultiIndexable#get in an earlier example. Slicing can drop dimensions, but it cannot change the return type. So, narr[region] will always return an NArray, regardless of the region you pass - even if it might seem counterintuitive:\nrequire \u0026#34;phase\u0026#34; include Phase narr = NArray[[1, 2], [3, 4]] # Let\u0026#39;s extract the top left element: narr[0, 0] # =\u0026gt; NArray[1] In the example shown, even though we\u0026rsquo;ve removed all the dimensions (we used fully integer coordinates), the return type cannot be changed to Int32 as you might expect. The #get method has a different method signature, and thus can return the element inside directly:\nnarr.get(0, 0) # =\u0026gt; 1 Alternatively, you can convert a single-element MultiIndexable to a scalar type using #to_scalar:\n# This is a worse choice than using #get for many reasons, but it is useful at times. narr[0, 0].to_scalar # =\u0026gt; 1 # This method also allows you to extract the sole element of a multidimensional structure: deep_scalar = NArray[[[[1]]]] deep_scalar.to_scalar # =\u0026gt; 1 # The above is easier than deep_scalar.get(0, 0, 0, 0) In certain use cases (typically when the region is passed to you by other, unknown code), you may want to disable dimension dropping. This can be done with an optional parameter:\nrqeuire \u0026#34;phase\u0026#34; include Phase def must_return_2d_matrix(region) narr = NArray[[1, 2], [3, 4]] return narr[region, drop: false] end # Even though the region literal we\u0026#39;re passing uses an integer index, # `drop: false` ensures that the output is the same number of dimensions # as `narr`. must_return_2d_matrix([0, ..]) # =\u0026gt; NArray[[1, 2]] Step Size # Unfortunately, Crystal\u0026rsquo;s ranges don\u0026rsquo;t support step sizes in the literal like, for example, Python (array[0:5:2]). However, Crystal\u0026rsquo;s flexibility enables a similarly simple syntax:\nrequire \u0026#34;phase\u0026#34; import Phase narr = NArray[[:a, :b, :c, :d], [ 1, 2, 3, 4], [:e, :f, :g, :h]] # Start at row zero, step by two, and select all columns implicitly: narr[0..2..] # =\u0026gt; NArray[[:a, :b, :c, :d], [:e, :f, :g, :h]] Note that, unlike Python\u0026rsquo;s slice syntax, which has the order start:stop:step, Phase uses the more natural order start..step..stop.\nYou can also use a triple-dot (...) before the final index, rather than a .., to make the stop value exclusive:\nnarr[0..2..2] # =\u0026gt; NArray[[:a, :b, :c, :d], [:e, :f, :g, :h]] narr[0..2...2] # =\u0026gt; NArray[[:a, :b, :c, :d]] # Note that the ellipsis before the step size is totally ignored. # narr[start..step..stop] always equals narr[start...step..stop] Under the hood, this stepped range syntax is admittedly a little hacky, but it\u0026rsquo;s convenient enough that we opted to stick with it. (If you\u0026rsquo;re curious how this works, 0..2..5 is actually equivalent to (0..2)..5, which is the literal for an instance of Range(Range(Int, Int), Int). When Phase dissects the region you pass, it notices objects with that type (or the related type, Range(Int, Range(Int, Int))), and breaks it down into the start, step, and stop indexes.)\n"},{"id":5,"href":"/docs/regions_and_chunks/index_region/","title":"The IndexRegion Type","section":"Regions \u0026 Chunks","content":" The IndexRegion Type # "}]