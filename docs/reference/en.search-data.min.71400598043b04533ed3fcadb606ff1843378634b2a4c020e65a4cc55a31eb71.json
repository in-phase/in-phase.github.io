[{"id":0,"href":"/docs/regions_and_chunks/","title":"Regions \u0026amp; Chunks","section":"Docs","content":"Regions \u0026amp; Chunks #  Introduction #  At its core, Phase is all about providing an easy to use container for storing large amounts of data. One of the most important parts of that task is providing an easy way for the user to extract a peice of data from the collection - for example, selecting only the first three elements from a vector, or isolating the green channel of an RGB image.\nAlthough it seems very simple, this topic can get quite confusing. Because Phase aims to make scientific computing easier to work with, we\u0026rsquo;re devoting a whole section to this one operation of taking an NArray (or, more specifically, a MultiIndexable) apart.\nTo begin with, we\u0026rsquo;ll review the Array from Crystal\u0026rsquo;s standard library. If you\u0026rsquo;re comfortable with slicing Arrays in Crystal already, skip to Adding Dimensions.\nArrays in One Dimension #  In an Array, each element is represented by a numeric index. There are a couple different ways to do this - we can refer to the elements via positive, increasing indexes as such:\narr = [\u0026#39;P\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;e\u0026#39;] # 0 1 2 3 4 arr[0] # =\u0026gt; \u0026#39;P\u0026#39; arr[4] # =\u0026gt; \u0026#39;e\u0026#39; Or, we can start at the other end of the array using negative indexes:\narr = [\u0026#39;P\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;e\u0026#39;] # -5 -4 -3 -2 -1 arr[-1] # =\u0026gt; \u0026#39;e\u0026#39; arr[-5] # =\u0026gt; \u0026#39;P\u0026#39; But the real complication arises when we want to select multiple elements from one array. In Crystal, this is done with a Range, often created with a range literal. A Range describes an ordered collection of indexes by a starting and ending index. Let\u0026rsquo;s construct a Range and see what indexes it refers to:\n# Create a range that starts at 0, and ends at 3 (including 3) range = Range.new(begin: 0, end: 3, exclusive: false) range.to_a # =\u0026gt; [0, 1, 2, 3] So, the range we created starts at 0, increments by 1 until it gives us 3, and then ends. Note that we specified exclusive: false, in that example. It\u0026rsquo;s often useful to exclude the last value (in the example here, 3). Here\u0026rsquo;s an example:\n# Create a range that starts at 0, and ends at 3 (excluding 3) range = Range.new(begin: 0, end: 3, exclusive: true) range.to_a # =\u0026gt; [0, 1, 2] Of course, the syntax shown above is very painful to type out. Instead, we use range literal syntax to shorten the expressions:\n# Inclusive ranges are start..end (two periods are used) inclusive_range = 0..3 inclusive_range.to_a # =\u0026gt; [0, 1, 2, 3] # Exclusive ranges use three periods: 0...3 exclusive_range = 0...3 exclusive_range.to_a #=\u0026gt; [0, 1, 2] Now that we\u0026rsquo;ve seen how a range can refer to multiple indexes, it\u0026rsquo;s easy to use them to sample elements from an array:\n# Let\u0026#39;s extract [\u0026#39;h\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;s\u0026#39;] from this array: arr = [\u0026#39;P\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;e\u0026#39;] # 0 1 2 3 4 # The indexes shown above tell us that we want elements # 1, 2, and 3. So, we\u0026#39;ll construct an appropriate range: selection_range = 1..3 selection_range.to_a # =\u0026gt; [1, 2, 3] # and use it on the array: arr[selection_range] # =\u0026gt; [\u0026#39;h\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;s\u0026#39;] This also works with negative indexes, but the end of the range has to be positively larger than the starting index:\narr = [\u0026#39;P\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;e\u0026#39;] # -5 -4 -3 -2 -1 # Let\u0026#39;s extract the last two letters: selection_range = -2..-1 selection_range.to_a # =\u0026gt; [-2, -1] arr[selection_range] # =\u0026gt; [\u0026#39;s\u0026#39;, \u0026#39;e\u0026#39;] Adding Dimensions #  "},{"id":1,"href":"/docs/tutorials/making-a-multiindexable/","title":"multiindexable_tutorial","section":"Test document","content":"Tutorial: Make Your Own MultiIndexable #  Basics #  ph-core offers a standard data type, Phase::NArray that will suffice for most of your multidimensional data storage and manipulation needs. However, storing information linearly in memory isn\u0026rsquo;t always the most effective appraoch, and sometimes isn\u0026rsquo;t possible. Phase::MultiIndexable is an interface defining a common set of rules we expect any multidimensional array to obey; and by implementing this interface, you can treat your own type almost like an NArray.\nLet\u0026rsquo;s say we want to be able to access any 5-digit number, using each place value as a coordinate. Since we want our array to return Int32s, that will be the type argument.\nrequire \u0026#34;ph-core\u0026#34; class NumberAccessor \u0026lt; Phase::MultiIndexable(Int32) end This alone won\u0026rsquo;t compile, because the MultiIndexable interface has two abstract methods it expects you to define. So let\u0026rsquo;s do that.\nrequire \u0026#34;ph-core\u0026#34; class NumberAccessor \u0026lt; Phase::MultiIndexable(Int32) def shape [10] * 5 # our NumberAccessor is 5-dimensional, with 10 possible values on each axis end # coord is an Indexable(Int), so we can iterate over it to get each singular *ordinate*. # In this example we are treating ordinates as digits of our final number, with  # place values corresponding to their position (index) in the coordinate. def unsafe_fetch_element(coord) : T value = 0 place_value = 1 coord.each do |digit| value += digit * place_value place_value *= 10 end end end That is technically all we need, and we can now start using our NumberAccessor.\n# examples Return Types #   Summary: there are several methods that return NArrays by default, but may be overriden to return your own type:\n #unsafe_fetch_chunk(region : IndexRegion) #map(\u0026amp;block) #map_with(*args, \u0026amp;block) .from(other : MultiIndexable)   Performance #   Summary: there are several methods designed to work for any MultiIndexable, at the possible cost of performance. Some we suggest overriding include:\n Iterator methods: #fast, #each Transform methods: #reshape, #permute, #reverse #unsafe_fetch_chunk #size  Phase::NArray may offer some inspiration on how these methods work and how they might be optimized.\n "},{"id":2,"href":"/docs/tutorials/","title":"Test document","section":"Docs","content":"Tutorials #  tuts!\n"}]